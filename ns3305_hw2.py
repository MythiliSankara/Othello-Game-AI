#!/usr/bin/env python3
# -*- coding: utf-8 -*

"""

An AI player for Othello.  

@author: Mythili Sankara
"""

import random
import sys
import time

# You can use the functions in othello_shared to write your AI

trav_dict = {}

from othello_shared import find_lines, get_possible_moves, get_score, play_move


def order_heuristic(moves, board, color, flip):
#This function takes in a list of moves, sorts them according to the heuristic values of the boards generated by them and returns the sorted list to the calling function
    move_list = []

    for move in moves:
        new_board = play_move(board, color, move[0], move[1])
        new_utility = compute_utility(new_board, color)
        move_list.insert(new_utility, move)
        # print("This is the first list",move_list)

    if flip == 2:
        move_list.sort(key=lambda x: x[0])
        return move_list
    elif flip == 1:
        move_list.sort(key=lambda x: x[0], reverse=True)
        return move_list


def swap_color(color):
#This swaps the color between both min and max positions.
    if color == 1:
        return 2
    elif color == 2:
        return 1


def compute_utility(board, color):

    if color == 1:
        player2 = 2
    elif color == 2:
        player2 = 1

    utility = 0
    for i in range(len(board)):
        for j in range(len(board)):
            if board[i][j] == color:
                utility += 1
            elif board[i][j] == player2:
                utility -= 1

    return utility


def minimax_min_node(board, color):
    old_moves = get_possible_moves(board, color)
#Takes the generated moves and returns them according to increasing order of heuristics
    moves = order_heuristic(old_moves, board, color, 1)
    # print("After the h",moves)

    if len(moves) == 0:
        return compute_utility(board, color)

    score = float('inf')
    for move in moves:
        new_board = play_move(board, color, move[0], move[1])
        #Checking to see if the board has already been stored in the dictionary
        if new_board in trav_dict:
            return trav_dict[new_board]
        else:
            trav_dict[new_board] = compute_utility(new_board, color)
            #Making a new board and value entry to the dictionary
            score = min(score, minimax_max_node(new_board, swap_color(color)))

    return score


def minimax_max_node(board, color):
    old_moves = get_possible_moves(board, color)
    moves = order_heuristic(old_moves, board, color, 2)

    if len(moves) == 0:
        return compute_utility(board, color)

    score = float('-inf')
    for move in moves:
        new_board = play_move(board, color, move[0], move[1])
        if new_board in trav_dict:
            return trav_dict[new_board]
        else:
            trav_dict[new_board] = compute_utility(new_board, color)
            score = max(score, minimax_min_node(new_board, swap_color(color)))

    return score


def select_move_minimax(board, color):
    moves = get_possible_moves(board, color)

    top_move = moves[0]
    top_score = float('-inf')

    for move in moves:

        score = minimax_min_node(board, color)

        if score > top_score:
            top_score = score
            top_move = move

    return top_move[0], top_move[1]


############ ALPHA-BETA PRUNING #####################


def alphabeta_min_node(board, color, alpha, beta,level,limit):

    old_moves = get_possible_moves(board, color)
    moves = order_heuristic(old_moves, board, color, 1)

    if level>=limit: #If the level equals limit, returns the value and stops search further down the nodes
        return compute_utility(board, color)

    level+=1
    #Incrementing the level each time a deeper node is visited
    score = float('inf')
    for move in moves:
        new_board = play_move(board, color, move[0], move[1])
        if new_board in trav_dict:
            return trav_dict[new_board]
        else:
            trav_dict[new_board] = compute_utility(new_board, color)
            score = min(score, alphabeta_max_node(new_board, swap_color(color), alpha, beta,level,limit))
            if score <= alpha:
                return score
            beta = min(beta, score)

    return score


def alphabeta_max_node(board, color, alpha, beta,level,limit):

    old_moves = get_possible_moves(board, color)
    moves = order_heuristic(old_moves, board, color, 2)

    if level>=limit:
        return compute_utility(board, color)

    level+=1
    score = float('-inf')
    for move in moves:
        new_board = play_move(board, color, move[0], move[1])
        if new_board in trav_dict:
            return trav_dict[new_board]
        else:
            trav_dict[new_board] = compute_utility(new_board, color)
            score = max(score, alphabeta_min_node(new_board, swap_color(color), alpha, beta,level,limit))
            if score >= beta:
                return score
            alpha = max(alpha, score)

    return score


def select_move_alphabeta(board, color):
    
    level=0
    limit=5
    moves = get_possible_moves(board, color)

    top_move = moves[0]
    alpha = float('-inf')
    beta = float('+inf')

    for move in moves:

        new_board = play_move(board, color, move[0], move[1])
        score = alphabeta_min_node(new_board, color, alpha, beta,level,limit)

        if score > alpha:
            top_score = score
            top_move = move

    return top_move[0], top_move[1]


####################################################
def run_ai():
    """
    This function establishes communication with the game manager.
    It first introduces itself and receives its color.
    Then it repeatedly receives the current score and current board state
    until the game is over.
    """
    print("Minimax AI")  # First line is the name of this AI
    color = int(input())  # Then we read the color: 1 for dark (goes first),
    # 2 for light.

    while True:  # This is the main loop
        # Read in the current game status, for example:
        # "SCORE 2 2" or "FINAL 33 31" if the game is over.
        # The first number is the score for player 1 (dark), the second for player 2 (light)
        next_input = input()
        status, dark_score_s, light_score_s = next_input.strip().split()
        dark_score = int(dark_score_s)
        light_score = int(light_score_s)

        if status == "FINAL":  # Game is over.
            print
        else:
            board = eval(input())  # Read in the input and turn it into a Python
            # object. The format is a list of rows. The
            # squares in each row are represented by
            # 0 : empty square
            # 1 : dark disk (player 1)
            # 2 : light disk (player 2)

            # Select the move and send it to the manager 
            #movei, movej = select_move_minimax(board, color)
            movei, movej = select_move_alphabeta(board, color)
            print("{} {}".format(movei, movej))


if __name__ == "__main__":
    # test_board=((0,0,0,0,1,0,0,0),(0,0,0,0,1,1,0,0),(1,1,1,1,1,1,1,2),(0,0,1,1,1,1,0,2),(0,0,1,1,1,0,0,2),(0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0))
    # test_board=((0,0,0,0),(0,1,2,0),(0,2,1,0),(0,0,0,0))
    # print(test_board[1][2])
    # move= select_move_minimax(test_board,1)
    # move=select_move_alphabeta(test_board,1)
    # print(move)
    # compute_utility(test_board,2)
    # ls=select_move_alphabeta(test_board,1)
    # print(ls)
    # print(trav_dict)

    run_ai()
